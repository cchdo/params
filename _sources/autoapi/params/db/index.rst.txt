params.db
=========

.. py:module:: params.db


Classes
-------

.. autoapisummary::

   params.db.CFStandardNameDC
   params.db.WHPNameDC
   params.db.ConfigDict
   params.db.Base
   params.db.Config
   params.db.Unit
   params.db.Param
   params.db.CFName
   params.db.CFAlias
   params.db.WHPName
   params.db.Alias


Functions
---------

.. autoapisummary::

   params.db.database
   params.db._str_or_type


Module Contents
---------------

.. py:class:: CFStandardNameDC

   Dataclass representing a single CF Standard Name

   This class captures the information in the standard name table as properties.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: canonical_units
      :type:  str | None


   .. py:attribute:: grib
      :type:  str | None


   .. py:attribute:: amip
      :type:  str | None


   .. py:attribute:: description
      :type:  str | None


   .. py:property:: cf
      Part of the `cf` interface, for :class:`CFStandardName` instances, just returns self



.. py:class:: WHPNameDC

   Dataclass representing a single exchange/WOCE style name + unit pair

   There is a ton of extra information that is meant for use in making CF/netCDF files.


   .. py:attribute:: whp_name
      :type:  str


   .. py:attribute:: nc_name
      :type:  str


   .. py:attribute:: nc_group
      :type:  str | None


   .. py:attribute:: rank
      :type:  float


   .. py:attribute:: dtype
      :type:  Literal['string', 'decimal', 'integer']


   .. py:attribute:: in_erddap
      :type:  bool


   .. py:attribute:: field_width
      :type:  int


   .. py:attribute:: whp_unit
      :type:  str | None
      :value: None



   .. py:attribute:: flag_w
      :type:  Literal['woce_discrete', 'woce_ctd', 'no_flags', 'woce_bottle'] | None


   .. py:attribute:: cf_name
      :type:  str | None
      :value: None



   .. py:attribute:: numeric_min
      :type:  float | None


   .. py:attribute:: numeric_max
      :type:  float | None


   .. py:attribute:: numeric_precision
      :type:  int | None


   .. py:attribute:: description
      :type:  str | None


   .. py:attribute:: note
      :type:  str | None


   .. py:attribute:: warning
      :type:  str | None


   .. py:attribute:: error_name
      :type:  str | None


   .. py:attribute:: cf_unit
      :type:  str | None


   .. py:attribute:: reference_scale
      :type:  str | None


   .. py:attribute:: whp_number
      :type:  int | None


   .. py:attribute:: scope
      :type:  str


   .. py:attribute:: analytical_temperature_name
      :type:  str | None


   .. py:attribute:: analytical_temperature_units
      :type:  str | None


   .. py:attribute:: radiation_wavelength
      :type:  float | None


   .. py:attribute:: scattering_angle
      :type:  float | None


   .. py:attribute:: excitation_wavelength
      :type:  float | None


   .. py:attribute:: emission_wavelength
      :type:  float | None


   .. py:attribute:: alt_depth
      :type:  int


   .. py:attribute:: whp_name_alias
      :type:  str | None


   .. py:attribute:: whp_unit_alias
      :type:  str | None


   .. py:attribute:: error_col
      :type:  bool


   .. py:attribute:: flag_col
      :type:  bool


   .. py:method:: as_depth(depth: int) -> WHPName


   .. py:method:: as_alias(param, unit) -> WHPName


   .. py:method:: as_error() -> WHPName


   .. py:method:: as_flag() -> WHPName


   .. py:property:: full_whp_name


   .. py:property:: full_nc_name


   .. py:property:: full_error_name


   .. py:property:: key
      WHPNames are uniquely identified by a tuple of their (whp_name, whp_unit) values



   .. py:property:: odv_key
      :type: str

      An ODV style representation of the param in the form of "NAME [UNIT]"

      Note that the "[UNIT]" part is omitted if there are no units



   .. py:property:: nc_name_flag
      :type: str

      The variable name of the "flag" ancillary variable for this parameter



   .. py:property:: nc_name_error
      :type: str

      The variable name of the uncertainty ancillary variable for this parameter



   .. py:property:: data_type
      the actual python class for this WHPName's dtype

      This is useufl for parsing string values for this WHPName



   .. py:property:: cf
      :type: CFStandardName | None

      The :class:`CFStandardName` equivalent to this WHPName

      Returns none if there does not exist an equivalent :class:`CFStandardName`.



   .. py:method:: __eq__(other)

      :class:`WHPName`s are equivalent if their whp_name and whp_unit properties are equivalent



   .. py:method:: __hash__()

      Return hash(self).



   .. py:method:: __lt__(other)

      Sorts WHPNames based on their rank property



   .. py:method:: __repr__()

      Return repr(self).



   .. py:method:: get_nc_attrs(error=False)

      a dict containing the netCDF variable attributes needed for CF compliance for this variable



   .. py:method:: strfex(value, flag: bool = False, numeric_precision_override: int | None = None, date_or_time: Literal['date', 'time'] | None = None) -> str

      Format a value using standard WHP Exchange conventions:

      * dates are formatted as %Y%m%d
      * times are formatted as %H%M
      * fill values are "-999" for data, 9 for flags
      * for floating points, only NaN values are considered to be "fill", there
        are parameters which can have -999 as a real value

      :param value: the value to format as a string, the accepted inputs depends on the :class:`WHPName.dtype`,
                    dates and times are expected to be real `datetime.date` and `datetime.time` objects
      :param boolean flag: should `value` be interpreted as a WOCE flag
      :param int numeric_precision_override: if not None, will overrride the builtin databases :class:`WHPName.numeric_precision`
                                             when formatting floats

      :returns: `value` as a string for printing in a WHP Exchange file
      :rtype: str



.. py:function:: database()

.. py:class:: ConfigDict

   Bases: :py:obj:`collections.abc.MutableMapping`


   A MutableMapping is a generic container for associating
   key/value pairs.

   This class provides concrete generic implementations of all
   methods except for __getitem__, __setitem__, __delitem__,
   __iter__, and __len__.


   .. py:method:: __getitem__(key)


   .. py:method:: __setitem__(key, value)


   .. py:method:: __delitem__(key)
      :abstractmethod:



   .. py:method:: __iter__()


   .. py:method:: __len__()


.. py:class:: Base

   Bases: :py:obj:`sqlalchemy.orm.DeclarativeBase`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




.. py:function:: _str_or_type(val)

.. py:class:: Config

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'config'



   .. py:attribute:: key
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: value
      :type:  sqlalchemy.orm.Mapped[str]


.. py:class:: Unit

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ex_units'



   .. py:attribute:: id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: whp_unit
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: cf_unit
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: reference_scale
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: note
      :type:  sqlalchemy.orm.Mapped[str | None]


.. py:class:: Param

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'ex_params'



   .. py:attribute:: whp_name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: whp_number
      :type:  sqlalchemy.orm.Mapped[int | None]


   .. py:attribute:: description
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: note
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: warning
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: scope
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: dtype
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: flag
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: ancillary
      :type:  sqlalchemy.orm.Mapped[bool]


   .. py:attribute:: rank
      :type:  sqlalchemy.orm.Mapped[float]


   .. py:attribute:: in_erddap
      :type:  sqlalchemy.orm.Mapped[bool]


.. py:class:: CFName

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'cf_names'



   .. py:attribute:: standard_name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: canonical_units
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: grib
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: amip
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: description
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:property:: dataclass
      :type: params.CFStandardName



   .. py:property:: code


   .. py:method:: __repr__()

      Return repr(self).



.. py:class:: CFAlias

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'cf_aliases'



   .. py:attribute:: id
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: alias
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: standard_name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:method:: __repr__()

      Return repr(self).



.. py:class:: WHPName

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'whp_names'



   .. py:attribute:: whp_name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: whp_unit
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: standard_name
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: nc_name
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: nc_group
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: numeric_min
      :type:  sqlalchemy.orm.Mapped[float | None]


   .. py:attribute:: numeric_max
      :type:  sqlalchemy.orm.Mapped[float | None]


   .. py:attribute:: error_name
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: analytical_temperature_name
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: analytical_temperature_units
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: field_width
      :type:  sqlalchemy.orm.Mapped[int]


   .. py:attribute:: numeric_precision
      :type:  sqlalchemy.orm.Mapped[int | None]


   .. py:attribute:: param
      :type:  sqlalchemy.orm.Mapped[Param]


   .. py:attribute:: unit
      :type:  sqlalchemy.orm.Mapped[Unit]


   .. py:attribute:: cf_unit


   .. py:attribute:: radiation_wavelength
      :type:  sqlalchemy.orm.Mapped[float | None]


   .. py:attribute:: scattering_angle
      :type:  sqlalchemy.orm.Mapped[float | None]


   .. py:attribute:: excitation_wavelength
      :type:  sqlalchemy.orm.Mapped[float | None]


   .. py:attribute:: emission_wavelength
      :type:  sqlalchemy.orm.Mapped[float | None]


   .. py:attribute:: __table_args__


   .. py:property:: dataclass
      :type: params.WHPName



   .. py:property:: code
      :type: str



.. py:class:: Alias

   Bases: :py:obj:`Base`


   Base class used for declarative class definitions.

   The :class:`_orm.DeclarativeBase` allows for the creation of new
   declarative bases in such a way that is compatible with type checkers::


       from sqlalchemy.orm import DeclarativeBase

       class Base(DeclarativeBase):
           pass


   The above ``Base`` class is now usable as the base for new declarative
   mappings.  The superclass makes use of the ``__init_subclass__()``
   method to set up new classes and metaclasses aren't used.

   When first used, the :class:`_orm.DeclarativeBase` class instantiates a new
   :class:`_orm.registry` to be used with the base, assuming one was not
   provided explicitly. The :class:`_orm.DeclarativeBase` class supports
   class-level attributes which act as parameters for the construction of this
   registry; such as to indicate a specific :class:`_schema.MetaData`
   collection as well as a specific value for
   :paramref:`_orm.registry.type_annotation_map`::

       from typing_extensions import Annotated

       from sqlalchemy import BigInteger
       from sqlalchemy import MetaData
       from sqlalchemy import String
       from sqlalchemy.orm import DeclarativeBase

       bigint = Annotated[int, "bigint"]
       my_metadata = MetaData()

       class Base(DeclarativeBase):
           metadata = my_metadata
           type_annotation_map = {
               str: String().with_variant(String(255), "mysql", "mariadb"),
               bigint: BigInteger()
           }

   Class-level attributes which may be specified include:

   :param metadata: optional :class:`_schema.MetaData` collection.
    If a :class:`_orm.registry` is constructed automatically, this
    :class:`_schema.MetaData` collection will be used to construct it.
    Otherwise, the local :class:`_schema.MetaData` collection will supercede
    that used by an existing :class:`_orm.registry` passed using the
    :paramref:`_orm.DeclarativeBase.registry` parameter.
   :param type_annotation_map: optional type annotation map that will be
    passed to the :class:`_orm.registry` as
    :paramref:`_orm.registry.type_annotation_map`.
   :param registry: supply a pre-existing :class:`_orm.registry` directly.

   .. versionadded:: 2.0  Added :class:`.DeclarativeBase`, so that declarative
      base classes may be constructed in such a way that is also recognized
      by :pep:`484` type checkers.   As a result, :class:`.DeclarativeBase`
      and other subclassing-oriented APIs should be seen as
      superseding previous "class returned by a function" APIs, namely
      :func:`_orm.declarative_base` and :meth:`_orm.registry.generate_base`,
      where the base class returned cannot be recognized by type checkers
      without using plugins.

   **__init__ behavior**

   In a plain Python class, the base-most ``__init__()`` method in the class
   hierarchy is ``object.__init__()``, which accepts no arguments. However,
   when the :class:`_orm.DeclarativeBase` subclass is first declared, the
   class is given an ``__init__()`` method that links to the
   :paramref:`_orm.registry.constructor` constructor function, if no
   ``__init__()`` method is already present; this is the usual declarative
   constructor that will assign keyword arguments as attributes on the
   instance, assuming those attributes are established at the class level
   (i.e. are mapped, or are linked to a descriptor). This constructor is
   **never accessed by a mapped class without being called explicitly via
   super()**, as mapped classes are themselves given an ``__init__()`` method
   directly which calls :paramref:`_orm.registry.constructor`, so in the
   default case works independently of what the base-most ``__init__()``
   method does.

   .. versionchanged:: 2.0.1  :class:`_orm.DeclarativeBase` has a default
      constructor that links to :paramref:`_orm.registry.constructor` by
      default, so that calls to ``super().__init__()`` can access this
      constructor. Previously, due to an implementation mistake, this default
      constructor was missing, and calling ``super().__init__()`` would invoke
      ``object.__init__()``.

   The :class:`_orm.DeclarativeBase` subclass may also declare an explicit
   ``__init__()`` method which will replace the use of the
   :paramref:`_orm.registry.constructor` function at this level::

       class Base(DeclarativeBase):
           def __init__(self, id=None):
               self.id = id

   Mapped classes still will not invoke this constructor implicitly; it
   remains only accessible by calling ``super().__init__()``::

       class MyClass(Base):
           def __init__(self, id=None, name=None):
               self.name = name
               super().__init__(id=id)

   Note that this is a different behavior from what functions like the legacy
   :func:`_orm.declarative_base` would do; the base created by those functions
   would always install :paramref:`_orm.registry.constructor` for
   ``__init__()``.




   .. py:attribute:: __tablename__
      :value: 'whp_alias'



   .. py:attribute:: old_name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: old_unit
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: whp_name
      :type:  sqlalchemy.orm.Mapped[str]


   .. py:attribute:: whp_unit
      :type:  sqlalchemy.orm.Mapped[str | None]


   .. py:attribute:: __table_args__


